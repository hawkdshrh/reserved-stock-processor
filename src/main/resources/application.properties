quarkus.http.port=8090

quarkus.kafka-streams.topics=reserved-stock,shipments,orders

kafka.bootstrap.servers=${BOOTSTRAP_SERVERS}

kafka.security.protocol=SASL_SSL
kafka.sasl.mechanism=OAUTHBEARER
kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="${CLIENT_ID}" \
  oauth.client.secret="${CLIENT_SECRET}" \
  oauth.token.endpoint.uri="${TOKEN_ENDPOINT_URI}" ;
kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler

mp.messaging.outgoing.orders-out.connector=smallrye-kafka
mp.messaging.outgoing.orders-out.topic=orders
mp.messaging.outgoing.orders-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer

quarkus.kafka-streams.security.protocol=SASL_SSL
quarkus.kafka-streams.sasl.mechanism=OAUTHBEARER
quarkus.kafka-streams.sasl.jaas-config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
  oauth.client.id="${CLIENT_ID}" \
  oauth.client.secret="${CLIENT_SECRET}" \
  oauth.token.endpoint.uri="${TOKEN_ENDPOINT_URI}" ;
kafka-streams.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler

# Quick reconnection for dev mode
kafka-streams.consumer.heartbeat.interval.ms=200
kafka-streams.reconnect.backoff.max.ms=30000


# datasource configuration
quarkus.datasource.db-kind = postgresql
quarkus.datasource.username = stock_level_user
quarkus.datasource.password = stock_level_password
quarkus.datasource.jdbc.url = jdbc:postgresql://10.0.0.204:5432/stock_level_db

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.database.generation=drop-and-create
quarkus.hibernate-orm.packages=org.acme.beans